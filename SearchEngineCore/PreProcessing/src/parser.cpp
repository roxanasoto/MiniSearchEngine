#include <iostream>
#include <fstream>
#include <sstream>
#include <dirent.h>
#include <algorithm>
#include <string>

#include "../include/parser.h"

using namespace std;

Parser::Parser(){}

///*** Created by Roxana Soto
///*** Read Raw Data and generates files for each Document ***//
bool Parser::ReadRawData()
{    
    DIR *dir;
	struct dirent *ent;	
	char buffer[1000];    
	string path = "../../../../raw.es/"; 
	if ((dir = opendir ("../../../../raw.es")) != NULL) {        
		while ((ent = readdir (dir)) != NULL) {				
			archivo = fopen((path + ent->d_name).data(), "r");
			if (archivo==NULL){                
                cout<<"DIR not found!"<<endl;
			    return false;
			}
			else{                
				while ( fgets (buffer , 1000 , archivo) != NULL ){                    
                    if(buffer[0]=='<' && buffer[1]=='/'){
                        //tercer caso
                        fclose (archivo_destino);			  		
                    }                        
                    else if(buffer[0]=='<' && buffer[1]=='d'){                        
                        //primer caso
                        int index=0;
                        id=""; 
                        titulo=""; 

                        while(buffer[index]!='"'){
                            index++;
                        }
                        index++;
                        while(buffer[index]!='"'){
                            id+=buffer[index++];
                        }				       		
                        index++;
                        while(buffer[index]!='"'){
                            index++;
                        }
                        index++;
                        while(buffer[index]!='"'){
                            titulo+=buffer[index++];
                        }	                        
                        string ruta_nueva="../../../../DocsTest/";                        
                        archivo_destino = fopen((ruta_nueva + id + ".txt").data(), "w");
                        fputs(id.data(),archivo_destino);
                        fputs("\n",archivo_destino);
                        fputs(titulo.data(),archivo_destino);
                        fputs("\n",archivo_destino);


                    }
                    else{
                        //segundo caso
                        body="";				       		
                        body+=buffer;
                        fputs(body.data(), archivo_destino);
                    }
  			    }
  		    }
	        fclose (archivo);
	  	}
	}
    else{
        cout<<"DIR not found!";
    }
  	return 0;
}

bool Parser::LoadStopWords(string fileName)
{
    set<string>::iterator it;
    ifstream ifs;
    ifs.open(fileName);	
    //cout<<"Loading..."<<endl;
    if (ifs.is_open()){
        string word;
        while (!ifs.eof()) {
            word = "";
            ifs >> word;
            if(word.compare("") != 0)
                stopWordsList.insert(word);               
        }
        ifs.close();            
	}
    else{
        cout<<"ERROR opening the file" <<endl;
        return false;
    }		
	//cout<<"Total items: " <<stopWordsList.size() <<endl;
    
    /*for (it=stopWordsList.begin(); it!=stopWordsList.end(); ++it)
        cout << ' ' << *it;*/
	return true;
}

///*** Created by Solange Ramos
///*** Reads each document generated by ReadRawData and clean them.  ***//
///*** Signs, accents and special characters are eliminated (á, é, ?... )  ***//
map<string, int> Parser::ParseFile(string _inputFile)
{    
    ifstream ifs;
    map<string, int> wordsList;
    map<string, int>::iterator it_ins = wordsList.begin();
    map<string, int>::iterator it_srch = wordsList.begin();
    ifs.open(_inputFile);    
    if (ifs.is_open()){
        bool is_title = true;
        string title, word, doc_id, line_content;		
		istringstream iss;
        getline(ifs, doc_id);                

        do {
            getline(ifs, line_content);
            is_title = false; //Second line is title, should weigth more
            iss.str(line_content);
		    while (iss >> word) {
			    PreProcessWord(word);
                //Save Word in list
			    if (!IsStopWord(word) && !word.empty()) {                    
                    it_srch = wordsList.find(word);
                    if (it_srch != wordsList.end()){                        
                         (*it_srch).second += 1;    
                    }
                    else{                        
                        wordsList.insert (it_ins, pair<string,int>(word,1));
                        it_ins++;                        
                    }
			    }
		    }
            iss.clear(); 
        }while(!ifs.eof());

        cout<<endl;
        ifs.close();            
	}
    else{
        cout<<"ERROR opening the file" <<endl;        
    }	

	ifs.close();   
    return wordsList; 
}

bool Parser::IsStopWord(string word){
    return stopWordsList.find(word) != stopWordsList.end();
}

bool Parser::IsMark(char sign) {
	return (sign < 0);
}

bool Parser::TakeOffMark(char &sign) {
	switch (sign) {
	case -95:
		sign = 'a';
		break;
	case -87:
		sign = 'e';
		break;
	case -83:
		sign = 'i';
		break;
	case -77:
		sign = 'o';
		break;
	case -70:
		sign = 'u';
		break;
	case -79:
		sign = 'n';
		break;
    case -90:
		cout<<"-80"<<endl;
		break;
	case -91:
		cout<<"-81"<<endl;
		break;
	case -92:
		cout<<"-82"<<endl;
		break;
	case -93:
		cout<<"-73"<<endl;
		break;
	case -94:
		cout<<"-84"<<endl;
		break;
	case -85:
		cout<<"-85"<<endl;
		break;
	case -96:
		cout<<"-86"<<endl;
		break;
	case -97:
		cout<<"-77"<<endl;
		break;
	case -98:
		cout<<"-88"<<endl;
		break;
	case -99:
		cout<<"-89"<<endl;
		break;
	default:
		return false;
	}
	return true;	 
}

void Parser::PreProcessWord(string &word)
{
    //cout<<"word in: "<<word <<" "<<word.length()<<endl;    
    transform(word.begin(), word.end(), word.begin(), ::tolower);
    //cout<<"word lower: "<<word <<endl;
	for (int i = 0; i < word.length(); ++i) {		
		if (IsMark(word[i])) {			
            word.erase(i, 1);
			while (i < word.length() && !TakeOffMark(word[i])) {				
				word.erase(i, 1);
			}
		} while (i < word.length() && !isalpha(word[i]) && !isdigit(word[i])) {			
            word.erase(i, 1);
		}
	}
    //cout<<"word out: "<<word<<endl;	
}

Parser::~Parser()
{    
    //Clean WordList and stopWordList
}